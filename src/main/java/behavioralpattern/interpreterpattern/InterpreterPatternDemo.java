package behavioralpattern.interpreterpattern;

/**
 * 解释器模式（InterpreterPattern）是指定一门语言，定义他的文法的一种表示，并定义一个解释器，
 * 该解释器使用该表示来解释语言中的局子。是一种按照规定的语法（文法）进行解析的模式，
 * 属于行为型模式。
 *
 * 就比如编译器可以将源码变异解释为机器码，让CPU能进行识别并运行。解释器模式的作用其实与编译器
 * 一样，都是将一些固定的文法（即语法）进行解释，构建出一个解释句子的解释器。简单理解，解释器
 * 是一个简单语法分析工具，他可以识别句子语义，分离中介符号和非中介符号，提出需要的信息，
 * 让我们能针对不同的信息做出相应的处理。其核心思想是识别语法，构建解释
 *
 * 解释器模式的应用场景
 * 我们的程序中，如果存在一种特定类型的问题，该类型问题设计多个不同实例，但是具备固定文法
 * 描述，那么可以使用解释器模式对该类型问题进行解释，分理处需要的信息，根据获取的信息
 * 做出相应的处理。简而言之，对于一些固定文法构建一个解释句子的解释器。解释器模式适用于
 * 一下应用场景：
 * 1、一些重复出现的问题可以用一种简单的语言来进行表达；
 * 2、一个简单语法需要解释的场景
 *
 * 主要包含四种角色
 * 抽象表达式（Expression）:负责定义一个解释方法interpret，交由具体子类进行具体解释；
 * 终结符表达式（TerminalExpression）：实现文法中与终结符相关的解释操作。文法中的每一个
 * 终结符都有一个具体终结表达式与之相对应，比如公式R=R1+R2,R1和R2就是终结符，对应的解析
 * R1和R2的解释器就是终结符表达式。通常一个解释器模式中只有一个终结符表达式，但是有多个
 * 实例，对应不同的终结符(R1,R2);
 * 非终结符表达式（NonterminalExpression）：实现文法中与非终结符有关的解释操作。
 * 文法中的每条规则都对应于一个非终结符表达式。非终结符表达式一般是文法中的运算符
 * 或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符
 * 表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符
 * 表达式
 * 上下文环境类（Context）：包含解释器之外的全局星系，它的任务一般是用来存放文法中各个
 * 终结符对应的具体值，比如R=R1+R2,给R1赋值100，给R2复制200，这些信息需要存放到环境中
 *
 * 解释器模式的优缺点
 * 优点：
 * 1、扩展性强：在解释器模式中由于语法是有很多类表示的，当语法规则更改是，只需修改相应
 * 的非终结符表达式即可；若扩展语法时，只需添加相应非终结符类即可;
 * 2、增加了新的解释器表达式的方式；
 * 3、易于实现文法：解释器模式对应的文法应当是比较简单且易于实现的，过于复杂的语法并不
 * 适合是用解释器模式
 * 缺点：
 * 1、语法规则较复杂时，会引起类膨胀：解释器模式每个语法都要产生一个非终结符表达式，
 * 当语法规则比较复杂时，就会产生大量的解释类，增加系统维护困难；
 * 2、执行效率比较低：解释器模式采用递归调用方法，每个非终结符表达式只关心与自己有关
 * 的表达式，每个表达式需要知道最终的结果，因此完整表达式的最终结果是通过从后往前递归
 * 调用的方式获取得到。当完整表达式层级比较深时，即使是效率下降，且出错时调试困难，因为
 * 递归迭代层级太深
 */
public class InterpreterPatternDemo {
    public static void main(String[] args) {
        System.out.println("result:" + new GPCalculator("10 + 30").calculate());
        System.out.println("result:" + new GPCalculator("10 + 30 - 20").calculate());
        System.out.println("result:" + new GPCalculator("10 * 2 + 400 * 1 +66").calculate());
        System.out.println("result:" + new GPCalculator("10 / 2").calculate());

    }
}
